<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8 />
	<title>Canvas Practivce</title>
	<!--<script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>-->
	<script src="https://code.createjs.com/easeljs-0.8.2.min.js"></script>

	<!--[if IE]>
		<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>
<body onload="Setup();">
	<style type="text/css">
		html, body {
			height:100%;
			width: 100%;
			margin: 0;
			padding: 0;
		}

		#canvasWrapper {
			position: absolute;
			width: 100%;
			height: 100%;
		}
		#homeCanvas {
			height: 100%;
			border: 1px solid black;
			
		}

	</style>

	<div id="canvasWrapper">
	<canvas id="homeCanvas" width="1000;" height="1000;">
	</canvas>
	</div>
	<script type="text/javascript">
	<!--
	/*
	Need to define this in the most general sense. 
	Just define number of dots in each direction required, do the math to figure out how to space it and where to put them.
	*/
		function getRandomInt(min, max) {
    		return Math.floor(Math.random() * (max - min + 1)) + min;
		}
		function getRandomFloat(min, max) {
    		return Math.random() * (max - min) + min;
		}

		function distance(t) {
			/*
			Will take a t |  0 < t < 1 and return a perfent representing how far along the dot should be.
			*/

			return 0.5*(-Math.cos(t * Math.PI) + 1);

		}
		
		var c=document.getElementById('homeCanvas');
		var ctx=c.getContext('2d');	

		var globalID;
		//an array of points in space. 
		var dots = [];
		var stage;
		var text;
		var g;
		var ball;
		var maxi = 12, maxj = 12, maxk = 10;
		var distance = 5.0;

		var maxVisionDepth = 50;
		var xSpeed = 0.4;
		var ySpeed = 0.4;
		var zSpeed = 0.002;
		var n = 2.0;
		var canvasWidth = 1000;
		var canvasHeight = 1000;
		var xSpace = canvasWidth / (n-1);
		var ySpace = canvasHeight / (n-1);
		var zSpace = 5;

		var xLength = xSpace*(maxi);
		var yLength = ySpace*(maxj);
		var startx = -xSpace*(maxi-n)/2;
		var starty = -ySpace*(maxj-n)/2;
		var endx = xLength + startx;
		var endy = yLength + starty;

		function Dot(x, y, z) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.vx = 0;
			this.vy = 0;
			this.vz = 0;


			this.update = function(delta) {

				this.distance += vx*delta;
				this.distance += vy*delta;
				this.distance += vz*delta;

				if (Math.abs(distance) >= xSpace ) {
					//Change direction
					this.vy = ySpeed * Math.sign(vx);
					this.vx = 0;
					this.distance = 0;
				} else if (vy !== 0 && Math.abs(distance) >= ySpace ) {
					//Change direction
					vz = zSpeed * Math.sign(vy);
					this.vy = 0;
					this.distance = 0;
				} else if (vz !== 0 && Math.abs(distance) >= zSpace ) {
					//Change direction
					this.vx = xSpeed * Math.sign(vz);
					this.vz = 0;
					this.distance = 0;
				} 

				if (this.z > maxVisionDepth) {
					this.z = vz*delta;
					this.x = vx*delta;
					this.y = vy*delta;
				} else {
					this.z += vz*delta;
					this.x += vx*delta;
					this.y += vy*delta;
				}
			}
		}

		function Dot(x, y, z, vx, vy, vz) {

			this.self = this;
			this.x = x;
			this.y = y;
			this.z = z;
			this.vx = vx;
			this.vy = vy;
			this.vz = vz;
			this.distance = 0;


			this.update = function(delta) {

				this.distance += this.vx*delta;
				this.distance += this.vy*delta;
				this.distance += this.vz*delta;

				if (this.vx !== 0 && Math.abs(this.distance) >= xSpace) {
					//Change direction
					this.vy = ySpeed * Math.sign(this.vx);
					this.vx = 0;
					this.distance = 0;
				} else if (this.vy !== 0 && Math.abs(this.distance) >= ySpace ) {
					//Change direction
					this.vz = zSpeed * Math.sign(this.vy);
					this.vy = 0;
					this.distance = 0;
				} else if (this.vz !== 0 && Math.abs(this.distance) >= zSpace ) {
					//Change direction
					this.vx = xSpeed * Math.sign(this.vz);
					this.vz = 0;
					this.distance = 0;
				} 

				this.x += this.vx*delta;
				this.y += this.vy*delta;
				this.z += this.vz*delta;

				if (this.x < startx) {
					this.x += xLength;
				} else if (this.x > endx) {
					this.x -= xLength;
				}

				if (this.y < starty) {
					this.y += yLength;
				} else if (this.y > endy) {
					this.y -= yLength;
				}

				if (this.z < 0) {
					this.z += maxVisionDepth;
				} else if (this.z > maxVisionDepth) {
					this.z -= maxVisionDepth;
				}

			}
		}



		var camera = new Dot(500, 500, 0);

		function Setup() {
			c.style.backgroundColor = "#EEE";

			stage = new createjs.Stage("homeCanvas");


			for (k = 0; k < maxk; k++) {
				for (i = 0; i < maxi; i++) {
					for (j = 0; j < maxj; j++) {
						dots.push(new Dot(i*xSpace + startx, j*ySpace + starty, k*zSpace + 1, xSpeed*(((j+k) % 2) * 2 - 1), 0, 0));
					}
				}
			}
			

			text = new createjs.Text("60", "bold 20px Arial", "#ff7700");
			
			stage.addChild(text);


			createjs.Ticker.timingMode = createjs.Ticker.RAF;
			createjs.Ticker.addEventListener("tick", Animate);
		}

		function compare(a, b) {
			return b.z - a.z;
		}

		function Animate(event) {
			/*Update objects here.*/
			//circle.x = circle.x + 100*event.delta/1000;
			//if (circle.x > stage.canvas.width) { circle.x = 0; }
			text.text = createjs.Ticker.getMeasuredFPS().toFixed(2) + " ---- " + Math.abs(dots[100].distance).toFixed(0) + " - " + dots[100].vx+ " - " + dots[100].vy+ " - " + dots[100].vz + " ---- " + dots[100].x.toFixed(0);
			stage.update();

			/*
			TODO:
			three steps to animation
			keep dots sorted on z-index at each step?

			insert new ones into the correct side of the array to make sure they are displayed properly

			look into the tween library

			*/

			for (var i = 0; i < maxi; i++) {
				for (var j = 0; j < maxj; j++) {
					for (var k = 0; k < maxk; k++) {
						//Update

						curDot = dots[k + j*maxk + i*maxj*maxk];
						curDot.update(event.delta);

					}
				}
			}

			//dots.sort(compare);

			for (var i = 0; i < maxi; i++) {
				for (var j = 0; j < maxj; j++) {
					for (var k = 0; k < maxk; k++) {
						curDot = dots[k + j*maxk + i*maxj*maxk];

						//Render
						ctx.beginPath();
						ctx.arc(
							(curDot.x - camera.x) * 1*distance/curDot.z + camera.x,
							(curDot.y - camera.y) * 1*distance/curDot.z + camera.y,
							 /*45 * Math.min(1, (distance/curDot.z)*(distance/curDot.z)),*/
							 23 * 	(Math.abs(distance)/curDot.z),
							 0,
							 2*Math.PI);
						ctx.fillStyle = 'black';
      			ctx.fill();
						ctx.stroke();
					}
				}
			}

		}

		

		/*
		$("#start").on("click", function() {
		  globalID = requestAnimationFrame(Animate);
		});

		$("#stop").on("click", function() {
		  cancelAnimationFrame(globalID);
		});
		*/



	-->
	</script>
 
</body>
</html>