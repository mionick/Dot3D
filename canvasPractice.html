<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8 />
	<title>Canvas Practivce</title>
	<!--<script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>-->
	<script src="https://code.createjs.com/easeljs-0.8.2.min.js"></script>

	<!--[if IE]>
		<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>
<body onload="Setup();">
	<style type="text/css">
		html, body {
			height:100%;
			width: 100%;
			margin: 0;
			padding: 0;
		}

		#canvasWrapper {
			position: absolute;
			width: 100%;
			height: 100%;
		}
		#homeCanvas {
			height: 100%;
			border: 1px solid black;
			
		}

	</style>

	<div id="canvasWrapper">
	<canvas id="homeCanvas" width="1000;" height="1000;">
	</canvas>
	</div>
	<script type="text/javascript">
	<!--
	/*
	Need to define this in the most general sense. 
	Just define number of dots in each direction required, do the math to figure out how to space it and where to put them.
	*/
		function getRandomInt(min, max) {
    		return Math.floor(Math.random() * (max - min + 1)) + min;
		}
		function getRandomFloat(min, max) {
    		return Math.random() * (max - min) + min;
		}

		function distance(t) {
			/*
			Will take a t |  0 < t < 1 and return a perfent representing how far along the dot should be.
			*/

			return 0.5*(-Math.cos(t * Math.PI) + 1);

		}
		
		var c=document.getElementById('homeCanvas');
		var ctx=c.getContext('2d');	

		var globalID;
		//an array of points in space. 
		var dots = [];
		var stage;
		var text;
		var g;
		var ball;
		var maxi = 12, maxj = 12, maxk = 10;

		var period = 3000; //milliseconds for 1 movement.

		var maxVisionDepth = maxk * zSpace;
		var maxXdistance = maxVisionDepth * 100;
		var maxYdistance = maxVisionDepth * 100;

		var n = 2.0;
		var canvasWidth = 1000;
		var canvasHeight = 1000;
		var xSpace = canvasWidth / (n-1);
		var ySpace = canvasHeight / (n-1);
		var zSpace = 5;

		var xLength = xSpace*(maxi);
		var yLength = ySpace*(maxj);
		var startx = -xSpace*(maxi-n)/2;
		var starty = -ySpace*(maxj-n)/2;
		var endx = xLength + startx;
		var endy = yLength + starty;

		function Dot(xi, yi, zi, state, direction, directionz) {

			this.self = this;
			this.x = xi;
			this.y = yi;
			this.z = zi;
			this.xi = xi;
			this.yi = yi;
			this.zi = zi;

			this.xf = xi;
			this.yf = yi;
			this.zf = zi;

			this.direction = direction;
			this.directionz = directionz;



			if (this.currentState == 0) {
				//Next modify the x coord
				this.xf = this.xi + xSpace* direction;
			} else if (this.currentState == 1) {
				this.yf = this.yi + ySpace* direction;
			} else if (this.currentState == 2) {
				this.zf = this.zi + zSpace* directionz;
			}
			
			this.lastTime = 0;

			this.currentState = state;

			this.update = function(time) {

				if (time - this.lastTime > period) {
					this.x = this.xf;
					this.y = this.yf;
					this.z = this.zf;
					this.xi = this.xf;
					this.yi = this.yf;
					this.zi = this.zf;
					this.lastTime = time - time % period;

					if (this.currentState == 0) {
						//Next modify the x coord
						this.xf = this.xi + xSpace* direction;
					} else if (this.currentState == 1) {
						this.yf = this.yi + ySpace* direction;
					} else if (this.currentState == 2) {
						this.zf = this.zi + zSpace* directionz;
					}

					this.currentState ++;
					this.currentState = this.currentState % 3;
				}

				delta = time %period;
				delta = delta / period;
				this.x = this.xi + (this.xf - this.xi)*distance(delta);
				this.y = this.yi + (this.yf - this.yi)*distance(delta);
				this.z = this.zi + (this.zf - this.zi)*distance(delta);

				//Check if it is within visible range
				if (this.z >= maxVisionDepth) {
					this.z -= maxVisionDepth;
					this.zi -= maxVisionDepth;
					this.zf -= maxVisionDepth;
				} else if (this.z < 0) {
					this.z += maxVisionDepth;
					this.zi += maxVisionDepth;
					this.zf += maxVisionDepth;	
				}
				

			}
		}



		var camera = new Dot(500, 500, -5);

		function Setup() {
			c.style.backgroundColor = "#EEE";

			stage = new createjs.Stage("homeCanvas");


			for (k = 0; k < maxk; k++) {
				for (i = 0; i < maxi; i++) {
					for (j = 0; j < maxj; j++) {
						dots.push(new Dot(i*xSpace + startx, j*ySpace + starty, k*zSpace + 1, 0, ((j+k) % 2) * 2 - 1, ((i+k) % 2) * 2 - 1));
					}
				}
			}
			

			text = new createjs.Text("60", "bold 20px Arial", "#ff7700");
			
			stage.addChild(text);


			createjs.Ticker.timingMode = createjs.Ticker.RAF;
			createjs.Ticker.addEventListener("tick", Animate);
		}

		function compare(a, b) {
			return b.z - a.z;
		}

		function Animate(event) {
			/*Update objects here.*/
			//circle.x = circle.x + 100*event.delta/1000;
			//if (circle.x > stage.canvas.width) { circle.x = 0; }
			text.text = createjs.Ticker.getMeasuredFPS().toFixed(2) ;
			stage.update();

			/*
			TODO:
			three steps to animation
			keep dots sorted on z-index at each step?

			insert new ones into the correct side of the array to make sure they are displayed properly

			look into the tween library

			*/

			time = createjs.Ticker.getTime();
			for (var i = 0; i < maxi; i++) {
				for (var j = 0; j < maxj; j++) {
					for (var k = 0; k < maxk; k++) {
						//Update
						curDot = dots[k + j*maxk + i*maxj*maxk];
						curDot.update(time);

					}
				}
			}

			//dots.sort(compare);

			for (var i = 0; i < maxi; i++) {
				for (var j = 0; j < maxj; j++) {
					for (var k = 0; k < maxk; k++) {
						curDot = dots[k + j*maxk + i*maxj*maxk];

						//Render
						ctx.beginPath();
						ctx.arc(
							(curDot.x - camera.x) * -camera.z/curDot.z + camera.x,
							(curDot.y - camera.y) * -camera.z/curDot.z + camera.y,
							 /*45 * Math.min(1, (-camera.z/curDot.z)*(distance/curDot.z)),*/
							 23 * 	(Math.abs(-camera.z/curDot.z)),
							 0,
							 2*Math.PI);
						ctx.fillStyle = 'black';
      			ctx.fill();
						ctx.stroke();
					}
				}
			}

		}

		

		/*
		$("#start").on("click", function() {
		  globalID = requestAnimationFrame(Animate);
		});

		$("#stop").on("click", function() {
		  cancelAnimationFrame(globalID);
		});
		*/



	-->
	</script>
 
</body>
</html>